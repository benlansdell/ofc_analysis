---
title: "ROC multiple recordings"
output: html_notebook
---

## ROC analysis for all cells

In this notebook:
* Study how the responsiveness changes from recording to recording

Imports
```{r}
library(hash)
library(data.table)
library(ggplot2)
library(plotly)
library(htmltools)

source('helper.R')
```

Set local working directory (change to your own) and path to the data
```{r}
setwd('/home/blansdel/projects/roc_cell_analysis')
path = '/media/core/core_operations/ImageAnalysisScratch/Schwarz/Cameron/ImagingData/'
```

Set parameters for the analysis:
```{r}
events_of_interest = c('lspout_first', 'rspout_first')  #Events to study 
N = 1000                                                #Number of null ROC curves to generate
alpha = 0.05                                            #Alpha value to determine significance
```

### Match cells

Load the results data.table that was generated by `2_ROC_multirecording.Rmd`
```{r}
dt_roc = fread('./results/roc_analysis.csv')
dt_roc
```

An important consideration when comparing across recordings is the reward direction of each session:
```{r}
unique(dt_roc[, .(Session, Reward), by = Animal])
```

To analyize the results, we find cells that are in all recordings of the same animal.

First, get rid of the cells with MatchID == 0 -- these weren't matched between any recordings.
```{r}
matched_roc = dt_roc[MatchID != 0,.(recording, Animal, CellID, MatchID)]
matched_roc
```

Then from this make a `matched_cells` table that contains cells that have matches in _all_ recordings of a given animal. 
```{r}
matched_cells = data.table()
n_animals = matched_roc[, uniqueN(recording), by = Animal]
animals = unique(matched_roc$Animal)
for (animal in animals) { 
  n = n_animals[Animal == animal, V1]
  matched_cells = rbind(matched_cells, matched_roc[Animal == animal, if(.N == n) .(recording, CellID), by = .(Animal, MatchID)])
}
matched_cells
```

Using this, filter the results table, dt_roc, to only include cells that are represented in all recordings of the animal
```{r}
setkeyv(dt_roc, c("Animal", "MatchID", "recording", "CellID"))
setkeyv(matched_cells, c("Animal", "MatchID", "recording", "CellID"))
dt_roc = merge(dt_roc, matched_cells, nomatch = 0)
```

Now we have a table full of matched cells.
```{r}
dt_roc
```

### Analyze the matched cells

Now we can do some stats on this table.

For each animal and event, we can classify each matched cell as:
* Insignificant in all sessions (none)
* Significant in all sessions (either all_pos, all_neg)
* One that changes its significance between sessions (mixed)

Now we compute an extra column that classifies each cell by its positive or negative responsiveness to each event according to the above categories. 
```{r}
classify = function(n_pos_sig, n_neg_sig, n_rec) {
  if (n_pos_sig == n_rec) return('all_pos')
  if (n_neg_sig == n_rec) return('all_neg')
  if ((n_pos_sig == 0) & (n_neg_sig == 0)) return('none')
  return('mixed')
}

for (animal in animals) { 
  n = n_animals[Animal == animal, V1]
  for (evt in events_of_interest) {
    #Put all matched cells into one of the above categories
    col_pos = paste(evt, 'pos_resp', sep = "_")
    col_neg = paste(evt, 'neg_resp', sep = "_")
    dt_roc[Animal == animal, 
           eval(paste(evt, 'class', sep = "_")) := classify(sum(.SD[[1]]), sum(.SD[[2]]), n),
           by = .(Animal, MatchID), 
           .SDcols = c(col_pos, col_neg)]
  }
}
```

```{r}
dt_roc
```

Let's summarize the cell's class across recordings:
```{r}
dt_summary = unique(dt_roc[,.(Animal, MatchID, lspout_first_class, rspout_first_class)])
dt_summary
```

Per animal, how many cells are there of each class?
```{r}
dt_summary[, .N, by = .(Animal, lspout_first_class)]
```

```{r}
dt_summary[, .N, by = .(Animal, rspout_first_class)]
```

But this doesn't take into account the reward location of the sessions, which is probably an important factor in the cells' responses.

So next we summarize the results for the left and right reward sessions. 
```{r}
unique(dt_roc[, .(Reward, N_lspout_first_p = sum(lspout_first_pos_resp), N_lspout_first_n = sum(lspout_first_neg_resp), N_rspout_first_p = sum(rspout_first_pos_resp), N_rspout_first_n = sum(rspout_first_neg_resp), .N), by = .(Animal, Session)])
```

Now plot some traces aligned with each event of interest, for each animal, sorted by the above categories

```{r}

make_facet_plot = function(animal = 6, evt = 'lspout_first', window = 1000) {

  facet_labeller <- function(variable,value){ return(facet_names[value])}
  quantile_rank = function(rank) {return(0.1 + rank/10)}
    
  files = unique(dt_roc[Animal == animal, recording])
  
  #Make a big data table that houses all trace info
  dt_animal = data.table()
  facet_names = list()
  for (fn in files) {
    #Load the data for that session 
    dt = readRDS(paste(path, fn, sep = ''))
    ds = preprocess_dt(dt, events_of_interest)
    reward = dt[1,Reward]
    ds[, dff_zs := (dff - mean(dff))/sd(dff), by = CellID]
    ds[, recording := fn]
    trials = ds[event == evt, .SD[which.min(frame)], by = `Trial Number`]$`Trial Number`
    dss = ds[frame_offset_event > -window & frame_offset_event < window & `Trial Number` %in% trials,
             .(Session = unique(Session), `Mean activity` = mean(dff)),
             by = .(frame_offset_event, CellID, recording)]
    facet_names[[unique(dss$Session)]] = paste('Session:', dss$Session, 'Reward:', reward, 'Trials:', length(trials))
    dss = dss %>% mutate(CellID = as.numeric(CellID))
    dss = dss %>% mutate(`Mean activity` = as.numeric(`Mean activity`))
    dss = dss %>% mutate(Session = as.numeric(Session))
    dss = merge(dss, dt_roc, by=c('recording', 'Session', 'CellID'), all = FALSE)
    dt_animal = rbind(dt_animal, dss)
  }
  
  #Sort by responsiveness
  colname = paste('null_quantile', evt, sep = "_")
  null_quantile = dt_animal[[colname]]
  colname = paste(evt, 'class', sep = "_")
  cls = dt_animal[[colname]]
  cls_order = list('all_pos' = 3, 'mixed' = 2, 'none' = 1, 'all_neg' = 0)
  
  #Set the order of the plot:
  
  #Just the quantile
  #dt_animal[,class_order := null_quantile]
  #Sort by the class and then the quantile
  dt_animal[,class_order := quantile_rank(null_quantile) + sapply(cls, function (x) cls_order[[x]][[1]])]
  #Just the class
  #dt_animal[,class_order := sapply(cls, function (x) cls_order[[x]])]
  
  #Determine the number of cells in each category
  cn = paste(evt, 'class', sep = '_')
  n_all_pos = sum(dt_animal[(frame_offset_event == 0) & (recording == files[1])][[cn]] == 'all_pos')
  n_all_neg = sum(dt_animal[(frame_offset_event == 0) & (recording == files[1])][[cn]] == 'all_neg')
  n_mixed = sum(dt_animal[(frame_offset_event == 0) & (recording == files[1])][[cn]] == 'mixed')
  n_none = sum(dt_animal[(frame_offset_event == 0) & (recording == files[1])][[cn]] == 'none')
  
  #Then make a facet plot, with the number of facets being the number of sessions
  p = ggplot(dt_animal, aes(x=frame_offset_event, y=reorder(MatchID, class_order), fill = `Mean activity`)) +
    geom_tile(show.legend = TRUE) +
    facet_wrap(~Session, labeller = facet_labeller) +
    scale_fill_distiller(palette = "Spectral") +
    theme(axis.ticks.y = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank()) + 
    geom_hline(data = dt_animal, aes(yintercept=n_all_neg+n_none+n_mixed+0.5), color = "blue") + 
    geom_hline(data = dt_animal, aes(yintercept=n_all_neg+n_none+0.5), color = "orange") + 
    geom_hline(data = dt_animal, aes(yintercept=n_all_neg+0.5), color = "red") + 
    labs(title = paste("Animal:", animal, "Event:", evt), x = "Frame", y = "Cell")
  
  print(p)
}
```

```{r fig2, fig.height = 8, fig.width = 6}
make_facet_plot()
```

```{r fig3, fig.height = 8, fig.width = 6}
make_facet_plot(evt = 'rspout_first')
```

```{r fig4, fig.height = 8, fig.width = 6}
make_facet_plot(animal = 8)
```

```{r fig.height = 8, fig.width = 6}
make_facet_plot(animal = 8, evt = 'rspout_first')
```

```{r fig.height = 8, fig.width = 6}
make_facet_plot(animal = 10, evt = 'lspout_first')
```

```{r fig.height = 8, fig.width = 6}
make_facet_plot(animal = 10, evt = 'rspout_first')
```