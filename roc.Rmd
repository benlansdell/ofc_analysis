---
title: "ROC analysis"
output: html_notebook
---

## ROC analysis for cells

In this notebook:
* Perform ROC analysis on single recording to compute responsiveness score (RS)
* Plot traces aligned to events of interest, sorted by RS

```{bash}
ls /media/core/core_operations/ImageAnalysisScratch/Schwarz/Cameron/ImagingData/
```

Choose from one of the above files, and choose events to analyze
```{r}
fn = 'final_060603.Rds'
events_of_interest = c("lspout_first", "rspout_first")
```

And set local working directory (change to your own)
```{r}
setwd('/home/blansdel/projects/roc_cell_analysis')
```

Imports
```{r}
library(hash)
library(ROCR)
library(data.table)
library(ggplot2)

source('helper.R')
```

Load data
```{r}
path = '/media/core/core_operations/ImageAnalysisScratch/Schwarz/Cameron/ImagingData/'
dt = readRDS(paste(path, fn, sep = ''))
ds = preprocess_dt(dt, events_of_interest)
```

The loaded data table
```{r}
ds
```

### Preprocessing of signal

How much variability is there between trials for a given cell?
```{r}
a = ds[,.(mn = mean(dff), sd = sd(dff)), by = .(CellID, `Trial Number`)]
a[CellID == 1]
```

Normalize (z-score)

```{r}
ds[, dff_zs := (dff - mean(dff))/sd(dff), by = `CellID`]
ds
```

### ROC curves measuring responsiveness to events of interest

Compute the ROC curves. The signal is treated as a binary classifier for the experimental state of interest. Here, the states of interest are the first phases of the l/r spout states. After normalizing, we treat the signal as a simple binary classifier. That is, if it is above a given amount then it counts as 1, otherwise 0. We can use this to generate an ROC curve, which indicates how well that cell classifies times as the event of interest or not. The ROC AUC is used as a measure of cell responsiveness. 

Make a dictionary of ROC curves for each cellID
```{r}
roc_curves = hash()
per_cell_ds = split(ds, f = ds$CellID)
cells = unique(ds$CellID)
```

```{r}
for (evt in events_of_interest) {
  for (dss in per_cell_ds) {
    p = performance(prediction(dss$dff_zs, dss[,..evt]), "tpr", "fpr") 
    q = performance(prediction(dss$dff_zs, dss[,..evt]), "auc") 
    roc_curves[paste(evt, dss[1,CellID])] = list(p, q)
  }
}
```

Plot the ROC curves for all cells
```{r fig1, fig.height = 6, fig.width = 6}
for (evt in events_of_interest) {
  plot(roc_curves[[paste(evt, '1')]][[1]])
  lapply(cells, function(x) plot(roc_curves[[paste(evt,x)]][[1]], add = TRUE));
}
```

Make a new data table to house the results of our analysis.
```{r}
dt_roc = data.table(CellID = cells)
for (evt in events_of_interest){
  aucs = sapply(cells, function(x) roc_curves[[paste(evt, x)]][[2]]@y.values[[1]])
  dt_roc[,eval(paste(evt, 'AUC', sep = "_")) := aucs]
}
```

```{r}
dt_roc
```

### Generation of null-distributions for each cell

Now, for each cell, we perform N random shifts of the signal, and recompute the AUC. 

This gives us a null distribution from which we can judge an AUC as significant or not. 

(In the paper [1], N = 1000)

First confirm what the method looks like for a few cells.
```{r}
N = 50

n_cells = 1
cell <- sample(unique(ds$CellID), n_cells, replace=F)

dss = ds[CellID == cell]

for (evt in events_of_interest) {
  aucs = c()
  pred_real = performance(prediction(dss$dff_zs, dss[,..evt]), "tpr", "fpr")
  plot(pred_real, colorize = TRUE)
  colname = paste(evt, 'AUC', sep = "_")
  for (j in 1:N) {
    #Perform shuffle of data...
    rand_idx = ceiling(runif(1, 0, length(dss$dff_zs)))
    shuffle = cycle(dss$dff_zs, rand_idx)
    pred = performance(prediction(shuffle, dss[,..evt]), "tpr", "fpr")
    auc = performance(prediction(shuffle, dss[,..evt]), "auc")@y.values[[1]]
    aucs = c(aucs, auc)
    plot(pred, add = TRUE)
  }
  
  this_auc = dt_roc[CellID == cell, ..colname]
  quantile = sum(aucs < this_auc[[1]])/N
  
  plot(pred_real, colorize = TRUE, add = TRUE)
  title(sprintf("Event: %s, Cell %s, AUC: %f, quantile: %f", evt, cell, this_auc, quantile))
}
```

```{r}
hist(aucs, breaks = 10)
title(sprintf("Event: %s, Cell %s", evt, cell))
```

Now compute for all cells
```{r}
N = 1000
null_rocs = compute_roc_par(per_cell_ds, events_of_interest, dt_roc, N)
dt_roc = merge(dt_roc, null_rocs, by = 'CellID')
dt_roc
```

Compute statistical significance of each cell's responsiveness score
```{r}
alpha = 0.05

for (evt in events_of_interest) {
  colname = paste('null_quantile', evt, sep = "_")
  dss = dt_roc[,colname, with = FALSE]
  dt_roc[,(paste(evt, 'pos_resp', sep='_')) := (dss > 1-alpha)]
  dt_roc[,(paste(evt, 'neg_resp', sep='_')) := (dss < alpha)]
}
```

### Summarize the significantly responding cells

How many positively and negatively responding cells are there?
```{r}
for (evt in events_of_interest) {
  print(evt)
  cn_pos = paste(evt, 'pos_resp', sep = '_')
  cn_neg = paste(evt, 'neg_resp', sep = '_')
  print(sprintf("Positively responding cells: %d", sum(dt_roc[[cn_pos]])))
  print(sprintf("Negatively responding cells: %d", sum(dt_roc[[cn_neg]])))
}

print(sprintf("Out of %d cells", length(cells)))
```

### Plot activity of cells sorted by responsiveness

```{r fig6, fig.height = 10, fig.width = 5}
window = 1000

events_of_interest = c("lspout_first", "rspout_first")
reward = "left"

for (evt in events_of_interest) {
  trials = ds[event == evt, .SD[which.min(frame)], by = `Trial Number`]$`Trial Number`
  
  dss = ds[frame_offset_event > -window & frame_offset_event < window & `Trial Number` %in% trials, .(mn = mean(dff)), by = .(frame_offset_event, CellID)]
  
  #Sort by responsiveness
  dss = merge(dss, dt_roc, by='CellID')
  colname = paste('null_quantile', evt, sep = "_")
  null_quantile = dss[[colname]]
  dss[,null_order := null_quantile]

  p = ggplot(dss, aes(x=frame_offset_event, y=reorder(CellID, null_order), fill = mn)) + 
    geom_tile(show.legend = FALSE) + 
    scale_fill_distiller(palette = "BrBG") + 
    theme(axis.ticks.y = element_blank(), axis.text.y = element_blank(), axis.title.y = element_blank()) +
    ggtitle(sprintf("%s (averaged over %d trials; reward is on the %s)", evt, length(trials), reward))

  print(p)  
}
```

### TODO

* Pool data over multiple recordings

### References 

[1] "Cortical Representations of Conspecific Sex Shape Social Behavior" Kingsbury et al 2020