---
title: "ROC multiple recordings"
output:
  html_document:
    df_print: paged
---

## ROC analysis for all cells

In this notebook:
* Study how the responsiveness changes from recording to recording

Imports
```{r}
library(hash)
library(data.table)
library(ggplot2)
library(plotly)
library(htmltools)

source('helper.R')
```

Set local working directory (change to your own) and path to the data
```{r}
setwd("~/roc_cell_analysis")
path = '/media/core/core_operations/ImageAnalysisScratch/Schwarz/Cameron/ImagingData_GRIN680/'
```

Set parameters for the analysis:
```{r}
events_of_interest = c('lspout_first','rspout_first','middle_left', 'middle_right')  #Events to study 
N = 1000                                                #Number of null ROC curves to generate
alpha = 0.05                                            #Alpha value to determine significance
```

### Match cells

Load the results data.table that was generated by `2_ROC_multirecording.Rmd`
```{r}
dt_roc = fread('./results/roc_analysis_full_match_GRIN680.csv')
dt_roc
```

To analyize the results, we find cells that are in all recordings of the same animal.

First, get rid of the cells with MatchID == 0 -- these weren't matched between any recordings.
```{r}
matched_roc = dt_roc[MatchID != 0,.(recording, Animal, CellID, MatchID)]
matched_roc
```

Then from this make a `matched_cells` table that contains cells that have matches in _all_ recordings of a given animal. 
```{r}
matched_cells = data.table()
n_animals = matched_roc[, uniqueN(recording), by = Animal]
animals = unique(matched_roc$Animal)
for (animal in animals) { 
  n = 2
  matched_cells = rbind(matched_cells, matched_roc[Animal == animal, if(.N >= n) .(recording, CellID), by = .(Animal, MatchID)])
}
matched_cells
```


```{r}
matched_cells = data.table()
n_animals = matched_roc[, uniqueN(recording), by = Animal]
animals = unique(matched_roc$Animal)
for (animal in animals) { 
  n = n_animals[Animal == animal, V1]
  matched_cells = rbind(matched_cells, matched_roc[Animal == animal, if(.N == n) .(recording, CellID), by = .(Animal, MatchID)])
}
matched_cells
```

Using this, filter the results table, dt_roc, to only include cells that are represented in all recordings of the animal
```{r}
setkeyv(dt_roc, c("Animal", "MatchID", "recording", "CellID"))
setkeyv(matched_cells, c("Animal", "MatchID", "recording", "CellID"))
dt_roc = merge(dt_roc, matched_cells, nomatch = 0)
```

Now we have a table full of matched cells.
```{r}
dt_roc
```

### Analyze the matched cells

Now we can do some stats on this table.

For each animal and event, we can classify each matched cell as:
* Non-responding in all sessions (none)
* Significantly responsive in all sessions (either all_pos, all_neg)
* A cell that changes its response between sessions (mixed)

We compute an extra column that classifies each cell by its positive or negative responsiveness to each event according to the above categories. 
```{r}
classify = function(n_pos_sig, n_neg_sig, n_rec) {
  if (n_pos_sig == n_rec) return('all_pos')
  if (n_neg_sig == n_rec) return('all_neg')
  if ((n_pos_sig == 0) & (n_neg_sig == 0)) return('none')
  return('mixed')
}

for (animal in animals) { 
  n = n_animals[Animal == animal, V1]
  for (evt in events_of_interest) {
    #Put all matched cells into one of the above categories
    col_pos = paste(evt, 'pos_resp', sep = "_")
    col_neg = paste(evt, 'neg_resp', sep = "_")
    dt_roc[Animal == animal, 
           eval(paste(evt, 'class', sep = "_")) := classify(sum(.SD[[1]]), sum(.SD[[2]]), n),
           by = .(Animal, MatchID), 
           .SDcols = c(col_pos, col_neg)]
  }
}
```

```{r}
dt_roc
```

Let's summarize the cell's class across recordings:
```{r}
dt_summary = unique(dt_roc[,.(Animal, MatchID, lspout_first_class, rspout_first_class,middle_left_class,middle_right_class)])
dt_summary
```

Per animal, how many cells are there of each class?
```{r}
dt_summary[, .N, by = .(Animal, lspout_first_class)]
```

```{r}
dt_summary[, .N, by = .(Animal, rspout_first_class)]
```


```{r}
dt_summary[, .N, by = .(Animal, middle_left_class)]
```


```{r}
dt_summary[, .N, by = .(Animal, middle_right_class)]
```

But this doesn't take into account the reward location of the sessions, which is probably an important factor in the cells' responses.
```{r}
unique(dt_roc[, .(Session, Reward), by = Animal])
```

So next we simply count the number of responsive cells for each session. 
```{r}
unique(dt_roc[, .(Reward, N_lspout_first_p = sum(lspout_first_pos_resp), N_lspout_first_n = sum(lspout_first_neg_resp), N_rspout_first_p = sum(rspout_first_pos_resp), N_rspout_first_n = sum(rspout_first_neg_resp), N_middle_left_p = sum(middle_left_pos_resp), N_middle_left_n = sum(middle_left_neg_resp),
                  N_middle_right_p = sum(middle_right_pos_resp),N_middle_right_n = sum(middle_right_neg_resp), .N), by = .(Animal, Session)])
```


```{r}
unique(dt_roc[, .(Reward, N_lspout_first_p = sum(lspout_first_pos_resp), N_lspout_first_n = sum(lspout_first_neg_resp), N_rspout_first_p = sum(rspout_first_pos_resp), N_rspout_first_n = sum(rspout_first_neg_resp), .N), by = .(Animal, Session)])
```

Plot some traces aligned with each event of interest, for each animal, sorted by the above categories
```{r}
make_facet_plot = function(animal = 6, evt = 'lspout_first', window = 1000) {

  #animal = 10
  #evt = 'lspout_first'
  #window = 1000
  
  facet_labeller <- function(variable,value){ return(facet_names[value])}
  quantile_rank = function(rank) {return(0.1 + rank/10)}
    
  files = unique(dt_roc[Animal == animal, recording])
  
  #Make a big data table that houses all trace info
  dt_animal = data.table()
  facet_names = list()
  for (fn in files) {
    #Load the data for that session 
    dt = readRDS(paste(path, fn, sep = ''))
    ds = preprocess_dt(dt, events_of_interest)
    reward = dt[1,Reward]
    ds[, dff_zs := (dff - mean(dff))/sd(dff), by = CellID]
    ds[, recording := fn]
    trials = ds[event == evt, .SD[which.min(frame)], by = `Trial Number`]$`Trial Number`
    dss = ds[frame_offset_event > -window & frame_offset_event < window & `Trial Number` %in% trials,
             .(Session = unique(Session), `Mean activity` = mean(dff)),
             by = .(frame_offset_event, CellID, recording)]
    facet_names[[as.character(unique(dss$Session))]] = paste('Session:', unique(dss$Session), 'Reward:', reward, 'Trials:', length(trials))
    dss = dss %>% mutate(CellID = as.numeric(CellID))
    dss = dss %>% mutate(`Mean activity` = as.numeric(`Mean activity`))
    dss = dss %>% mutate(Session = as.numeric(Session))
    dss = merge(dss, dt_roc, by=c('recording', 'Session', 'CellID'), all = FALSE)
    dt_animal = rbind(dt_animal, dss)
  }
  
  facet_names = unlist(facet_names, use.names = TRUE)
  
  #Sort by responsiveness
  colname = paste('null_quantile', evt, sep = "_")
  null_quantile = dt_animal[[colname]]
  colname = paste(evt, 'class', sep = "_")
  cls = dt_animal[[colname]]
  cls_order = list('all_pos' = 3, 'mixed' = 2, 'none' = 1, 'all_neg' = 0)
  
  #Set the order of the plot:
  
  #Just the quantile
  #dt_animal[,class_order := null_quantile]
  #Sort by the class and then the quantile
  dt_animal[,class_order := quantile_rank(null_quantile) + sapply(cls, function (x) cls_order[[x]][[1]])]
  #Just the class
  #dt_animal[,class_order := sapply(cls, function (x) cls_order[[x]])]
  
  #Determine the number of cells in each category
  cn = paste(evt, 'class', sep = '_')
  n_all_pos = sum(dt_animal[(frame_offset_event == 0) & (recording == files[1])][[cn]] == 'all_pos')
  n_all_neg = sum(dt_animal[(frame_offset_event == 0) & (recording == files[1])][[cn]] == 'all_neg')
  n_mixed = sum(dt_animal[(frame_offset_event == 0) & (recording == files[1])][[cn]] == 'mixed')
  n_none = sum(dt_animal[(frame_offset_event == 0) & (recording == files[1])][[cn]] == 'none')

  #Then make a facet plot, with the number of facets being the number of sessions
  p = ggplot(dt_animal, aes(x=frame_offset_event, y=reorder(MatchID, class_order), fill = `Mean activity`)) +
    geom_tile(show.legend = TRUE) +
#    facet_wrap(~Session, labeller = facet_labeller) +
    facet_wrap(~Session, labeller = labeller(Session = facet_names)) +
    scale_fill_distiller(palette = "Spectral") +
    theme(axis.ticks.y = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.background = element_blank()) + 
    geom_vline(data = dt_animal, aes(xintercept=0), color = "black") + 
    geom_hline(data = dt_animal, aes(yintercept=n_all_neg+n_none+n_mixed+0.5), color = "blue") + 
    geom_hline(data = dt_animal, aes(yintercept=n_all_neg+n_none+0.5), color = "orange") + 
    geom_hline(data = dt_animal, aes(yintercept=n_all_neg+0.5), color = "red") + 
    labs(title = paste("Animal:", animal, "Event:", evt), x = "Frame", y = "Cell")
  
  print(p)
}
```

```{r fig2, fig.height = 10, fig.width = 7}
make_facet_plot(animal = 6, evt = 'lspout_first')
```
Cells below the red line have suppressed activity in all sessions. Those above the blue line have excited activity in all sessions. Those in between the red and orange do not respond in any condition. And those in between the orange and blue have mixed repsonses.

```{r fig3, fig.height = 10, fig.width = 7}
make_facet_plot(animal = 6, evt = 'rspout_first')
```

```{r fig4, fig.height = 10, fig.width = 7}
make_facet_plot(animal = 8, evt = 'lspout_first')
```

```{r fig.height = 10, fig.width = 7}
make_facet_plot(animal = 8, evt = 'rspout_first')
```

```{r fig.height = 10, fig.width = 10}
make_facet_plot(animal = 51, evt = 'lspout_first')
```

```{r fig.height = 10, fig.width = 10}
```


```{r}
dt_roc_up$lspout_first_pos_resp<-fifelse(dt_roc$lspout_first_pos_resp==TRUE,dt_roc$lspout_first_AUC,0.5)
dt_roc_up$lspout_first_neg_resp<-fifelse(dt_roc$lspout_first_neg_resp==TRUE,dt_roc$lspout_first_AUC,0.5)
dt_roc_up$rspout_first_pos_resp<-fifelse(dt_roc$rspout_first_pos_resp==TRUE,dt_roc$rspout_first_AUC,0.5)
dt_roc_up$rspout_first_neg_resp<-fifelse(dt_roc$rspout_first_neg_resp==TRUE,dt_roc$rspout_first_AUC,0.5)
dt_roc_up$middle_left_pos_resp<-fifelse(dt_roc$middle_left_pos_resp==TRUE,dt_roc$middle_left_AUC,0.5)
dt_roc_up$middle_left_neg_resp<-fifelse(dt_roc$middle_left_neg_resp==TRUE,dt_roc$middle_left_AUC,0.5)
dt_roc_up$middle_right_pos_resp<-fifelse(dt_roc$middle_right_pos_resp==TRUE,dt_roc$middle_right_AUC,0.5)
dt_roc_up$middle_right_neg_resp<-fifelse(dt_roc$middle_right_neg_resp==TRUE,dt_roc$middle_right_AUC,0.5)


```